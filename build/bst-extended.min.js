!function t(e,r,n){function o(a,s){if(!r[a]){if(!e[a]){var l="function"==typeof require&&require;if(!s&&l)return l(a,!0);if(i)return i(a,!0);var u=new Error("Cannot find module '"+a+"'");throw u.code="MODULE_NOT_FOUND",u}var c=r[a]={exports:{}};e[a][0].call(c.exports,function(t){var r=e[a][1][t];return o(r||t)},c,c.exports,t,e,r,n)}return r[a].exports}for(var i="function"==typeof require&&require,a=0;a<n.length;a++)o(n[a]);return o}({1:[function(t,e,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=function(t){return t&&t.__esModule?t:{default:t}}(t("./validators")),o=t("./object-attributes");const i=["valid","compare","toString"],a=["number","string","array","object","map","weakmap","set","weakset"];class s{constructor(t){(0,o.constant)(this,"dataType",t.dataType||"number");const e=t[this.dataType]||n.default[this.dataType];if(!e)throw`Missing validator for '${this.dataType}'. Choose from default data types (${a.join(", ")}) or if you set your own.\nIf you set your own data type, you must create method with the same name, which will check if inserted data are of that type.`;(0,o.constant)(this,"validator",e),i.forEach(e=>{const r=t[e];r&&t.hasOwnProperty(e)&&(0,o.constant)(this,e,r)})}valid(t){return null!==t&&void 0!==t&&this.validator(t)}compare(t,e){return t<e?-1:t>e?1:0}validTree(t){return t.dataType===this.dataType}toString(t){return t}}r.default=s},{"./object-attributes":6,"./validators":7}],2:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(r,"__esModule",{value:!0});var o=n(t("./node")),i=n(t("./controllers")),a=t("./object-attributes");class s{constructor(t){(0,a.constant)(this,{controllers:new i.default(t||{})})}valid(t){return this.controllers.valid(t)}validTree(t){return this.controllers.validTree(t)}compare(t,e){return this.controllers.compare(t,e)}toString(t){return this.controllers.toString(t)}insert(t,e){const r=t,n=new o.default(e);if(!t)return n;for(;t;){let e=this.controllers.compare(n.data,t.data);if(e<0){if(!t.left){t.left=n;break}t=t.left}else{if(!(e>0))return null;if(!t.right){t.right=n;break}t=t.right}}return r}getMin(t){for(;t.left;)t=t.left;return t.data}getMax(t){for(;t.right;)t=t.right;return t.data}getHeight(t){if(!t)return-1;const e=[t];let r=0;for(;e.length;){let t=e.length;if(0===t)return r;for(r++;t;){let r=e.shift();r.left&&e.push(r.left),r.right&&e.push(r.right),t--}}return r}isBalanced(t){if(!t)return!0;const e=this.getHeight(t.left),r=this.getHeight(t.right);return!(Math.abs(e-r)>1)&&(this.isBalanced(t.left)&&this.isBalanced(t.right))}isBalanced(t){if(!t)return!0;const e=[t];for(;e.length;);}findParentNode(t,e){let r=null,n=t,o=null;for(;n;){let t=this.controllers.compare(e,n.data);if(t<0)r=n,n=n.left,o="left";else{if(!(t>0))break;r=n,n=n.right,o="right"}}return{parent:r,current:n,side:o}}delete(t,e){const r=t.node;let n=this.findParentNode(r,e);if(!n.current)return!1;if(n.current.left&&n.current.right){const t={parent:null,current:n.current.right,side:"right"};for(;t.current.left;)t.parent=t.current,t.current=t.current.left,t.side="left";n.current.data=t.current.data,n=t}if(!n.parent)return t.node=null,!0;let o=n.current;return o.left?n.parent[n.side]=o.left:n.parent[n.side]=o.right,!0}findNode(t,e){const{current:r}=this.findParentNode(t,e);return r}includes(t,e){return null!==this.findNode(t,e)}getSortedData(t){return[...this.inorder(t)]}*preorder(t){if(!t)return;const e=[t];for(;e.length;){let t=e.pop();yield t.data,t.right&&e.push(t.right),t.left&&e.push(t.left)}}*inorder(t){const e=[];for(;e.length||t;)t?(e.push(t),t=t.left):(yield(t=e.pop()).data,t=t.right)}*postorder(t){const e=[];let r=null;for(;e.length||t;)if(t)e.push(t),t=t.left;else{let n=e[e.length-1];n.right&&r!==n.right?t=n.right:(yield n.data,r=e.pop())}}*breadthFirstSearch(t){if(!t)return;const e=[t];for(;e.length;){let t=e.shift();yield t.data,t.left&&e.push(t.left),t.right&&e.push(t.right)}}merge(t,e,r){const n=this.preorder(r.root);let o=n.next();for(;!o.done;)t.insert(o.value),o=n.next();return t}balance(t,e){if(!t)return;const r=Math.floor(e.length/2);t.data=e[r],r>0&&(t.left=new o.default,this.balance(t.left,e.slice(0,r))),r<e.length-1&&(t.right=new o.default,this.balance(t.right,e.slice(r+1,e.length)))}treeStructure(t){if(!t)return[];const e=[[this.toString(t.data)]],r=[t.left,t.right];let n=[],o=1,i=2**o;for(;r.length;){let t=r.shift();t?n.push(this.toString(t.data)):n.push(" "),n.length>=i&&(e.push(n),n=[],i=++o**2),t&&(r.push(t.left),r.push(t.right))}return e}}r.default=s},{"./controllers":1,"./node":5,"./object-attributes":6}],3:[function(t,e,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=function(t){return t&&t.__esModule?t:{default:t}}(t("./main"));r.default=n.default},{"./main":4}],4:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(r,"__esModule",{value:!0});var o=n(t("./validators")),i=n(t("./node")),a=n(t("./core")),s=t("./object-attributes");const l=new WeakMap,u=new WeakMap;class c{constructor(t){if(t instanceof c){const e=t,r=new this.constructor(u.get(e));return r.merge(e)}(0,s.permanent)(this,{root:null,size:0}),u.set(this,t);const e=new a.default(t);l.set(this,e),(0,s.constant)(this,"dataType",e.controllers.dataType)}insert(t){const e=l.get(this);if(!e.valid(t))return!1;const r=e.insert(this.root,t);return!!r&&(this.root=r,this.size++,!0)}delete(t){const e=l.get(this);if(!e.valid(t))return!1;const r={node:this.root};return!!e.delete(r,t)&&(this.root=r.node,this.size--,!0)}includes(t,e=this.root){o.default.node("includes",e);const r=l.get(this);return r.valid(t)&&r.includes(e,t)}findNode(t,e=this.root){o.default.node("findNode",e);const r=l.get(this);return r.valid(t)?r.findNode(e,t):null}getMin(t=this.root){return o.default.node("getMin",t)?l.get(this).getMin(t):null}getMax(t=this.root){return o.default.node("getMax",t)?l.get(this).getMax(t):null}getHeight(t=this.root){return o.default.node("getHeight",t)?l.get(this).getHeight(t):null}isBalanced(t=this.root){return o.default.node("isBalanced",t)?l.get(this).isBalanced(t):null}balance(){if(!this.root)return;const t=l.get(this),e=t.getSortedData(this.root),r=new i.default;return t.balance(r,e),this.root=r,this}destroy(){this.root=null,this.size=0;const t=u.get(this);return l.delete(this),l.set(this,new a.default(t)),this}getData(t="inorder",e=this.root){return this.root?(t=o.default.traversalType(t),o.default.node("getData",e),[...this.traverseDFS(t,e)]):null}*traverseBFS(t=this.root){return o.default.node("traverseBFS",t),yield*l.get(this).breadthFirstSearch(t)}*traverseDFS(t="preorder",e=this.root){return t=o.default.traversalType(t),o.default.node("traverseDFS",e),e?yield*l.get(this)[t](e):null}toString(t){if(!this.root)return console.log("Binary search tree is empty!"),"";const e=t?this.findNode(t):this.root;if(!e)return"";const r=l.get(this).treeStructure(e);r[r.length-1].length;let n="";return r.forEach((t,e)=>{t.forEach(t=>{n+=t+" "}),n+="\n"}),n}valueOf(){return NaN}merge(...t){t&&o.default.array(t[0])&&(t=t[0]);const e=l.get(this);return t.forEach((r,n)=>{if(!o.default.object(r)||!o.default.constructor(r,c))throw`Invalid input, argument on position ${n} is not instance of BinarySearchTree class.`;if(!e.validTree(r))throw`Can't merge two binary search trees with different data type: ${this.controllers.dataType} !== ${r.controllers.dataType}.\n-> Invalid argument on position ${n}/${t.length}.`;e.merge(this,e,r)}),this}}r.default=c},{"./core":2,"./node":5,"./object-attributes":6,"./validators":7}],5:[function(t,e,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=t("./object-attributes");class o{constructor(t,e=null,r=null){(0,n.permanent)(this,{data:t,left:e,right:r})}}r.default=o},{"./object-attributes":6}],6:[function(t,e,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.constant=r.permanent=void 0;var n=function(t){return t&&t.__esModule?t:{default:t}}(t("./validators"));const o={permanent:{enumerable:!1,configurable:!1,writable:!0},constant:{enumerable:!1,configurable:!1,writable:!1}},i=(t,e,r)=>{if(n.default.not("object",e)||n.default.not("object",r))throw new TypeError("Second and third parameters must be objects.");const i=Object.entries(r),a=o[t];for(let[t,r]of i){let n=Object.assign({value:r},a);Object.defineProperty(e,t,n)}};r.permanent=((t,e,r)=>{n.default.object(e)?i("permanent",t,e):i("permanent",t,{[e]:r})}),r.constant=((t,e,r)=>{n.default.object(e)?i("constant",t,e):i("constant",t,{[e]:r})})},{"./validators":7}],7:[function(t,e,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=function(t){return t&&t.__esModule?t:{default:t}}(t("./node"));const o={number(t){return"number"==typeof t},string(t){return"string"==typeof t},array(t){return Array.isArray(t)},object(t){return this.constructor(t,Object)},map(t){return this.constructor(t,Map)},weakmap(t){return this.constructor(t,WeakMap)},set(t){return this.constructor(t,Set)},weakset(t){return this.constructor(t,WeakSet)},constructor(t,e){return t instanceof e},node(t,e){if(null===e)return!1;if(!this.object(e)||!this.constructor(e,n.default))throw new TypeError(`Invalid argument '${e}' in '${t}' method. It must be an instance of the Node class.`);return!0},traversalType(t){if(!(t=t.toLowerCase()).match(/^(in|post|pre)order$/))throw new TypeError(`First parameter must be 'preorder', 'inorder' or 'postorder', not '${t}'`);return t},not(t,e,r){const n=this[t];if(!n){const e=Object.keys(this),r=e.indexOf("not");throw e.splice(r,1),new TypeError(`'${t}' is not defined validator. Select from: ${e.join(", ")}.`)}return!("constructor"===t?n.call(this,e,r):n.call(this,e))}};r.default=o},{"./node":5}]},{},[3]);
//# sourceMappingURL=bst-extended.min.js.map
